package com.kosmo.ex;

public class S31AnonymousLocalVar {
    /*


📘 익명 클래스 & 람다식에서 지역 변수 접근 제약 수업 정리

⸻

✅ 1. 기본 개념: 지역 변수 접근 가능?

익명 클래스와 람다식은 외부 지역 변수에 접근할 수 있지만, 조건이 있습니다:

void run() {
    int count = 10; // 외부 지역 변수

    Runnable r = new Runnable() {
        @Override
        public void run() {
            System.out.println(count); // 가능할까?
        }
    };
}

이 코드는 “가능”하지만, count는 절대로 변경할 수 없습니다.

⸻

✅ 2. 접근 가능한 변수 조건: final 또는 effectively final
	•	final: 선언 시 final int count = 10; 처럼 명시적으로 final
	•	effectively final: 한 번만 값이 대입되고, 이후 변경되지 않은 변수

즉, “한 번만 값이 대입된 변수”만 접근 가능

int count = 10; // effectively final
count = 20;     // ❌ 이 줄이 있으면 익명 클래스 내부에서 사용 불가


⸻

✅ 3. 왜 이런 제한이 필요한가?

💡 이유 1: 스코프(범위) 차이
	•	지역 변수는 메서드가 끝나면 사라지는 stack 영역 변수
	•	익명 클래스나 람다식은 메서드 종료 후에도 실행될 수 있는 객체
	•	따라서 지역 변수에 직접 접근하면, 메모리에 없는 값을 참조할 수도 있음

→ 그래서 컴파일러가 지역 변수를 복사해서 내부적으로 사용하도록 함
→ 변경이 금지되어야 일관성 있게 복사 가능

⸻

💡 이유 2: 복사된 값의 신뢰성

int num = 10;
Runnable r = () -> System.out.println(num); // 복사본 num=10
num = 20; // 실제 변수 변경되었지만, r에는 반영되지 않음

	•	이런 상황에서 복잡한 버그 발생 가능
	•	따라서 변경되지 않는 값만 복사하도록 강제

⸻

✅ 4. 람다식과 익명 클래스 모두 해당됨
	•	익명 클래스도, 람다식도 **외부 지역 변수에 접근하려면 final(또는 effectively final)**이어야 한다
	•	단, 인스턴스 필드는 자유롭게 접근 가능

class Outer {
    int value = 5;
    void method() {
        Runnable r = () -> System.out.println(value); // 필드 접근은 제한 없음
    }
}


⸻

✅ 5. 요약 정리표

변수 종류	익명 클래스/람다식 내부 접근 가능 여부	설명
final 지역 변수	✅ 가능	명시적으로 final
변경 안 된 지역 변수	✅ 가능	effectively final
변경된 지역 변수	❌ 불가	컴파일 에러
인스턴스 필드	✅ 가능	제한 없음


⸻

🧠 기억 공식

“익명 클래스와 람다식은 외부 지역 변수를 복사해 사용하기 때문에, 변경되면 안 된다.”

⸻
익명 클래스 & 람다식에서 지역 변수 접근 제약

“메서드 안의 지역 변수는 메서드가 끝나면 사라지는 일회성 데이터야.
그런데 익명 클래스나 람다식은 메서드 밖에서 나중에도 실행될 수 있는 객체야.

그래서 이 객체 안에서 메서드 안의 지역 변수에 직접 접근하게 되면,
이미 사라진 지역 변수에 접근하려고 할 위험이 생기지.

그래서 자바는 그걸 막기 위해 ‘변하지 않는 지역 변수만 복사해서 쓸 수 있게’ 제한을 둬.

즉, **값이 한 번만 설정되고 변경되지 않는 지역 변수(= effectively final)**만 복사해서 람다나 익명 클래스 내부에서 사용 가능하게 해주는 거야.”

⸻

🔍 짧게 정리하자면:
	•	지역 변수는 스택에 저장되고 메서드 종료 시 사라짐
	•	익명 클래스/람다식은 힙에 객체로 저장되어 계속 존재함
	•	둘의 생명주기가 다르기 때문에, 자바는 지역 변수의 복사본만 내부에서 사용 가능하게 제한함
	•	그 복사본이 신뢰 가능하려면, 원본이 절대 변경되지 않아야 함 → 그래서 final 조건이 필요함

⸻

✔ 결론적으로, 한 문장으로 설명하자면:

“지역 변수는 일시적이고, 익명 클래스/람다식은 오래 사는 객체니까,
직접 접근 대신 값만 복사해서 쓰게 제한하고,
그 값이 **절대 변하지 않아야 안전하니 final이거나 effectively final만 허용하는 거야.”
좋습니다! 아래는 익명 클래스와 람다식에서 지역 변수 접근 제약 (final, effectively final) 관련 수업 내용을 기반으로 한 객관식 문제 10문제입니다.

⸻

📘 익명 클래스 & 람다식 변수 접근 관련 문제 10제

문제 1

다음 중 익명 클래스 내부에서 외부 지역 변수에 접근하기 위한 조건으로 옳은 것은?

A. 변수는 반드시 static이어야 한다
B. 변수는 반드시 final이거나 effectively final이어야 한다
C. 변수는 클래스 필드여야 한다
D. 어떤 변수든 접근 가능하다

⸻

문제 2

람다식 내부에서 사용 가능한 지역 변수는 어떤 조건을 만족해야 하는가? A번

A. 한 번만 선언되고 이후 값이 바뀌지 않아야 한다
B. 반드시 static으로 선언되어야 한다
C. 필드 변수여야 한다
D. 지역 변수 접근은 불가능하다

⸻

문제 3

다음 코드에 대한 설명으로 옳은 것은? C번

void run() {
    int count = 10;
    Runnable r = () -> System.out.println(count);
    count++;
}

A. 정상 컴파일된다
B. count는 final이므로 문제없다
C. count는 변경되어 컴파일 에러가 발생한다
D. count는 static이 아니므로 접근 불가하다

⸻

문제 4

익명 클래스와 람다식 모두에 적용되는 지역 변수 접근 제약은? C번

A. 지역 변수는 복사되지 않고 참조된다
B. 지역 변수가 변경되어도 동기화된다
C. 지역 변수는 복사되며, 변경이 불가능해야 한다
D. 지역 변수에 자유롭게 접근 가능하다

⸻

문제 5

다음 중 람다식이 인스턴스 필드에 접근할 때의 특징은?

A. 접근이 불가능하다
B. final로 선언되어야 한다
C. 자유롭게 접근할 수 있다
D. 메서드 안에서는 접근할 수 없다

⸻

문제 6

왜 자바는 익명 클래스나 람다식에서 변경된 지역 변수에 접근하지 못하게 막는가?

A. 메모리 부족을 방지하기 위해
B. 동기화 오류를 방지하기 위해
C. 지역 변수의 생명주기가 짧기 때문에
D. 객체 생성이 느리기 때문에

⸻

문제 7

다음 중 컴파일 에러가 발생하는 경우는?

void method() {
    int x = 10;
    Runnable r = () -> System.out.println(x);
    x = 20;
}

A. x는 필드가 아니기 때문에 에러
B. x가 static이 아니라 에러
C. x가 변경되었기 때문에 에러
D. r이 람다식이 아니라 에러

⸻

문제 8

effectively final의 의미로 가장 적절한 것은?

A. final 키워드가 붙은 변수
B. 처음 선언 후 값을 한 번만 대입하고 더는 변경하지 않은 변수
C. 컴파일 타임에만 접근 가능한 변수
D. static 블록 안에서 선언된 변수

⸻

문제 9

다음 중 익명 클래스가 외부 지역 변수에 접근할 수 없는 경우는?

A. 해당 지역 변수의 값을 변경해야하는 경우
B. 해당 지역 변수가 final인 경우
C. 해당 지역 변수가 초기화만 된 경우
D. 해당 지역 변수가 다른 클래스의 멤버일 경우

⸻

문제 10

람다식은 어떤 방식으로 외부 지역 변수를 내부에서 사용할까?

A. 참조를 그대로 유지한다
B. 값을 복사해서 내부에 저장한다
C. 힙 메모리에 복사한다
D. static 필드에 저장한다

⸻
1번: B, 2번: A, 3번: C, 4번: C, 5번: C,6번: C, 7번: C, 8번: B, 9번: A, 10번: B
⸻*/
}
